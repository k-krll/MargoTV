const express = require('express');
const multer = require('multer');
const path = require('path');
const ffmpegStatic = require('ffmpeg-static');
const { spawn } = require('child_process');
const fs = require('fs');
const os = require('os');
const mongoose = require('mongoose');
const Video = require('./models/Video');
const Encoding = require('./models/Encoding');
const http = require('http');
const socketIO = require('socket.io');
const srt2vtt = require('srt-to-vtt');

const app = express();
const port = 3005;
const hostname = '0.0.0.0';
const APP_NAME = 'MargoTV';

// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MongoDB
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/margotv', {
  useNewUrlParser: true,
  useUnifiedTopology: true
}).then(() => {
  console.log('üì¶ MongoDB –ø–æ–¥–∫–ª—é—á–µ–Ω–∞');
}).catch(err => {
  console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ MongoDB:', err);
});

// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —à–∞–±–ª–æ–Ω–∏–∑–∞—Ç–æ—Ä–∞
app.set('view engine', 'ejs');
app.use(express.static('public'));

// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ multer –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + path.extname(file.originalname));
  }
});

const upload = multer({ 
  storage: storage,
  fileFilter: (req, file, cb) => {
    if (file.fieldname === 'video') {
      cb(null, file.mimetype.startsWith('video/'));
    } else if (file.fieldname === 'thumbnail') {
      cb(null, file.mimetype.startsWith('image/'));
    } else if (file.fieldname === 'subtitles') {
      cb(null, file.originalname.endsWith('.srt'));
    } else {
      cb(null, false);
    }
  }
});

// –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –≤–∏–¥–µ–æ
let videos = [];

// –î–æ–±–∞–≤—å—Ç–µ –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞ –ø–æ—Å–ª–µ –¥—Ä—É–≥–∏—Ö require
const isDev = process.env.NODE_ENV === 'development';

// –î–æ–±–∞–≤—å—Ç–µ –ø–æ—Å–ª–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ express
if (isDev) {
  app.use((req, res, next) => {
    console.log(`${req.method} ${req.url}`);
    next();
  });
}

// –î–æ–±–∞–≤–∏–º middleware –¥–ª—è CORS –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  next();
});

// –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
app.get('/', async (req, res) => {
  try {
    const videos = await Video.find().sort({ uploadDate: -1 });
    res.render('index', { 
      videos: videos,
      appName: APP_NAME 
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤–∏–¥–µ–æ:', error);
    res.status(500).send('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞');
  }
});

// –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∑–∫–∏
app.get('/upload', (req, res) => {
  res.render('upload', { appName: APP_NAME });
});

// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞ –≤–∏–¥–µ–æ
const QUALITY_PRESETS = {
  '240p': { height: 240, bitrate: '500k' },
  '360p': { height: 360, bitrate: '800k' },
  '480p': { height: 480, bitrate: '1500k' },
  '720p': { height: 720, bitrate: '2500k' },
  '1080p': { height: 1080, bitrate: '4000k' }
};

// –û–±–Ω–æ–≤–∏–º —Å—Ö–µ–º—É Encoding
const encodingSchema = new mongoose.Schema({
  // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–æ–ª—è ...
  qualities: [{
    resolution: String,
    status: String,
    progress: Number,
    path: String
  }],
  selectedQualities: [String]
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≤–∏–¥–µ–æ
app.post('/upload', upload.fields([
  { name: 'video', maxCount: 1 },
  { name: 'thumbnail', maxCount: 1 },
  { name: 'subtitles', maxCount: 1 }
]), async (req, res) => {
  try {
    const { title, description, qualities } = req.body;
    const selectedQualities = Array.isArray(qualities) ? qualities : [qualities];
    
    const videoFile = req.files['video'][0];
    const thumbnailFile = req.files['thumbnail'] ? req.files['thumbnail'][0] : null;
    const subtitlesFile = req.files['subtitles'] ? req.files['subtitles'][0] : null;

    // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ –≤–∏–¥–µ–æ
    const video = await Video.create({
      title,
      description,
      status: 'processing',
      path: 'processing',
      thumbnail: thumbnailFile ? `thumbnails/${Date.now()}${path.extname(thumbnailFile.originalname)}` : null
    });

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—É–±—Ç–∏—Ç—Ä—ã –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
    if (subtitlesFile) {
      const subtitlesPath = `subtitles/${Date.now()}.vtt`;
      const fullSubtitlesPath = path.join('public', subtitlesPath);
      
      // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
      const subtitlesDir = path.dirname(fullSubtitlesPath);
      if (!fs.existsSync(subtitlesDir)) {
        fs.mkdirSync(subtitlesDir, { recursive: true });
      }

      // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å—É–±—Ç–∏—Ç—Ä—ã –∏–∑ SRT –≤ VTT
      const srtStream = fs.createReadStream(subtitlesFile.path);
      const vttStream = fs.createWriteStream(fullSubtitlesPath);
      
      srtStream
        .pipe(srt2vtt())
        .pipe(vttStream);

      // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—É–±—Ç–∏—Ç—Ä–∞—Ö –≤ –±–∞–∑–µ
      video.subtitles = {
        path: subtitlesPath,
        language: 'ru',
        label: '–†—É—Å—Å–∫–∏–π'
      };
      await video.save();

      // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
      fs.unlinkSync(subtitlesFile.path);
    }

    // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–∏
    const encoding = await Encoding.create({
      videoId: video._id,
      status: 'pending',
      startTime: new Date()
    });

    encoding.selectedQualities = selectedQualities;
    encoding.qualities = selectedQualities.map(q => ({
      resolution: q,
      status: 'pending',
      progress: 0
    }));
    await encoding.save();

    res.json({ 
      success: true, 
      encodingId: encoding._id,
      redirectUrl: `/encoding-status/${encoding._id}`
    });

    processVideo(videoFile, thumbnailFile, video, encoding, io);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ:', error);
    res.status(500).json({ error: 'Upload error' });
  }
});

// –î–æ–±–∞–≤–ª—è–µ–º —Ä–æ—É—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞
app.get('/encoding-status/:id', (req, res) => {
  res.render('encoding-status', { 
    encodingId: req.params.id,
    appName: APP_NAME 
  });
});

// API endpoint –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞
app.get('/api/encoding-status/:id', async (req, res) => {
  try {
    const encoding = await Encoding.findById(req.params.id).populate('videoId');
    res.json(encoding);
  } catch (error) {
    res.status(500).json({ error: 'Status check error' });
  }
});

// –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ
async function processVideo(videoFile, thumbnailFile, video, encoding, io) {
  const inputPath = videoFile.path;
  const baseOutputPath = `public/videos/${Date.now()}`;

  console.log('üìù –î–µ—Ç–∞–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏:');
  console.log(`- –í—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª: ${inputPath}`);
  console.log(`- –ë–∞–∑–æ–≤—ã–π –ø—É—Ç—å –≤—ã—Ö–æ–¥–∞: ${baseOutputPath}`);
  console.log(`- –í—ã–±—Ä–∞–Ω–Ω—ã–µ –∫–∞—á–µ—Å—Ç–≤–∞: ${encoding.selectedQualities.join(', ')}`);

  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
    if (!fs.existsSync(inputPath)) {
      throw new Error(`–í—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: ${inputPath}`);
    }

    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
    const videosDir = path.dirname(baseOutputPath);
    if (!fs.existsSync(videosDir)) {
      fs.mkdirSync(videosDir, { recursive: true });
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ thumbnail
    if (thumbnailFile) {
      try {
        const thumbnailPath = `public/${video.thumbnail}`;
        const thumbnailDir = path.dirname(thumbnailPath);
        
        if (!fs.existsSync(thumbnailDir)) {
          fs.mkdirSync(thumbnailDir, { recursive: true });
        }
        
        fs.copyFileSync(thumbnailFile.path, thumbnailPath);
        fs.unlinkSync(thumbnailFile.path);
        console.log('‚úÖ –ü—Ä–µ–≤—å—é —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ');
      } catch (thumbnailError) {
        console.error('‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø—Ä–µ–≤—å—é:', thumbnailError);
        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–∞–∂–µ –µ—Å–ª–∏ —Å –ø—Ä–µ–≤—å—é –ø—Ä–æ–±–ª–µ–º–∞
      }
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ
    for (const quality of encoding.selectedQualities) {
      const preset = QUALITY_PRESETS[quality];
      const outputPath = `${baseOutputPath}_${quality}.mp4`;
      
      console.log(`\nüéØ –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ ${quality}:`);
      console.log(`- –í—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª: ${outputPath}`);
      console.log(`- –ù–∞—Å—Ç—Ä–æ–π–∫–∏: ${JSON.stringify(preset)}`);

      try {
        await encodeVideoQuality(
          inputPath, 
          outputPath, 
          preset, 
          3600, // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
          quality,
          encoding,
          io
        );
        console.log(`‚úÖ –ö–∞—á–µ—Å—Ç–≤–æ ${quality} —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ`);
      } catch (encodeError) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–∏ ${quality}:`, encodeError);
        throw encodeError; // –ü—Ä–µ—Ä—ã–≤–∞–µ–º –≤–µ—Å—å –ø—Ä–æ—Ü–µ—Å—Å –µ—Å–ª–∏ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å
      }
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤–∏–¥–µ–æ
    await Video.findByIdAndUpdate(video._id, {
      status: 'completed',
      path: `videos/${path.basename(baseOutputPath)}_${encoding.selectedQualities[0]}.mp4`
    });

    console.log('üéâ –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞');
    io.to(encoding._id.toString()).emit('encoding:completed');

  } catch (error) {
    console.error('‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ:', error);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ –æ—à–∏–±–∫—É
    await Video.findByIdAndUpdate(video._id, {
      status: 'error',
      error: error.message
    });

    io.to(encoding._id.toString()).emit('encoding:error', { 
      message: error.message,
      details: error.stack
    });

    // –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
    try {
      if (fs.existsSync(inputPath)) {
        fs.unlinkSync(inputPath);
      }
    } catch (cleanupError) {
      console.error('‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤:', cleanupError);
    }
  }
}

// –§—É–Ω–∫—Ü–∏—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –æ–¥–Ω–æ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞
async function encodeVideoQuality(inputPath, outputPath, preset, duration, quality, encoding, io) {
  return new Promise((resolve, reject) => {
    const args = [
      '-i', inputPath,
      '-c:v', 'libx264',
      '-c:a', 'aac',
      '-b:v', preset.bitrate,
      '-vf', `scale=-2:${preset.height}`,
      '-preset', 'medium',
      '-progress', 'pipe:1',
      outputPath
    ];

    console.log('üé¨ –ó–∞–ø—É—Å–∫ FFmpeg —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏:', args.join(' '));

    const ffmpegProcess = spawn(ffmpegStatic, args);
    let lastProgress = 0;

    ffmpegProcess.stdout.on('data', async (data) => {
      const lines = data.toString().trim().split('\n');
      const progressData = {};
      
      lines.forEach(line => {
        const [key, value] = line.split('=');
        progressData[key] = value;
      });

      if (progressData.out_time_ms) {
        const currentTime = parseInt(progressData.out_time_ms) / 1000000;
        const progress = Math.min((currentTime / duration) * 100, 100);
        
        if (progress - lastProgress >= 1) {
          lastProgress = progress;
          
          // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –≤ –ë–î
          await Encoding.updateOne(
            { _id: encoding._id, 'qualities.resolution': quality },
            { 
              $set: { 
                'qualities.$.progress': progress,
                'qualities.$.status': 'processing'
              }
            }
          );

          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ WebSocket
          io.to(encoding._id.toString()).emit('encoding:progress', {
            quality,
            progress,
            currentTime,
            duration,
            eta: ((duration - currentTime) / (progress / 100)).toFixed(0)
          });
        }
      }
    });

    ffmpegProcess.stderr.on('data', (data) => {
      console.log('‚ö†Ô∏è FFmpeg stderr:', data.toString());
    });

    ffmpegProcess.on('close', (code) => {
      if (code === 0) {
        console.log('‚úÖ FFmpeg —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–∞–±–æ—Ç—É');
        resolve();
      } else {
        console.error(`‚ùå FFmpeg –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –∫–æ–¥–æ–º ${code}`);
        reject(new Error(`FFmpeg exited with code ${code}`));
      }
    });

    ffmpegProcess.on('error', (err) => {
      console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ FFmpeg:', err);
      reject(err);
    });
  });
}

// –°–æ–∑–¥–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è thumbnails
['uploads', 'public/videos', 'public/thumbnails'].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// –ü–æ–ª—É—á–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π IP –∞–¥—Ä–µ—Å
function getLocalIP() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const interface of interfaces[name]) {
      // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º non-IPv4 –∏ internal (–Ω–∞–ø—Ä–∏–º–µ—Ä, 127.0.0.1)
      if (interface.family === 'IPv4' && !interface.internal) {
        return interface.address;
      }
    }
  }
  return '0.0.0.0';
}

const localIP = getLocalIP();

// –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
app.use((err, req, res, next) => {
  console.error('Error:', err);
  res.status(500).send('–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞');
});

// –°—Ç—Ä–∞–Ω–∏—Ü–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ
app.get('/edit/:id', async (req, res) => {
  try {
    const video = await Video.findById(req.params.id);
    if (!video) {
      return res.status(404).send('–í–∏–¥–µ–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
    }
    res.render('edit', { 
      video: video,
      appName: APP_NAME 
    });
  } catch (error) {
    res.status(500).send('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞');
  }
});

// API –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–∏–¥–µ–æ
app.post('/api/videos/:id', upload.single('thumbnail'), async (req, res) => {
  try {
    const { title, description } = req.body;
    const video = await Video.findById(req.params.id);
    
    if (!video) {
      return res.status(404).json({ error: '–í–∏–¥–µ–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–≤—å—é –µ—Å–ª–∏ –∑–∞–≥—Ä—É–∂–µ–Ω–æ –Ω–æ–≤–æ–µ
    if (req.file) {
      const thumbnailPath = `thumbnails/${Date.now()}${path.extname(req.file.originalname)}`;
      
      // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ –ø—Ä–µ–≤—å—é –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
      if (video.thumbnail) {
        const oldPath = path.join('public', video.thumbnail);
        if (fs.existsSync(oldPath)) {
          fs.unlinkSync(oldPath);
        }
      }

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤–æ–µ –ø—Ä–µ–≤—å—é
      fs.copyFileSync(req.file.path, `public/${thumbnailPath}`);
      fs.unlinkSync(req.file.path);
      video.thumbnail = thumbnailPath;
    }

    video.title = title;
    video.description = description;
    await video.save();

    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏' });
  }
});

// API –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤–∏–¥–µ–æ
app.delete('/api/videos/:id', async (req, res) => {
  try {
    const video = await Video.findById(req.params.id);
    
    if (!video) {
      return res.status(404).json({ error: '–í–∏–¥–µ–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
    }

    // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª—ã
    if (video.path) {
      const videoPath = path.join('public', video.path);
      if (fs.existsSync(videoPath)) {
        fs.unlinkSync(videoPath);
      }
    }

    if (video.thumbnail) {
      const thumbnailPath = path.join('public', video.thumbnail);
      if (fs.existsSync(thumbnailPath)) {
        fs.unlinkSync(thumbnailPath);
      }
    }

    // –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å –∏–∑ –ë–î
    await video.deleteOne();
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏' });
  }
});

// API –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Å—É–±—Ç–∏—Ç—Ä–æ–≤
app.delete('/api/videos/:id/subtitles', async (req, res) => {
  try {
    const video = await Video.findById(req.params.id);
    
    if (!video) {
      return res.status(404).json({ error: '–í–∏–¥–µ–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
    }

    if (video.subtitles && video.subtitles.path) {
      const subtitlesPath = path.join('public', video.subtitles.path);
      if (fs.existsSync(subtitlesPath)) {
        fs.unlinkSync(subtitlesPath);
      }
    }

    video.subtitles = undefined;
    await video.save();
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å—É–±—Ç–∏—Ç—Ä–æ–≤' });
  }
});

const server = http.createServer(app);
const io = socketIO(server);

// WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
io.on('connection', (socket) => {
  console.log('üîå WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');

  socket.on('join:encoding', (encodingId) => {
    socket.join(encodingId);
    console.log(`üë• –ö–ª–∏–µ–Ω—Ç –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ: ${encodingId}`);
  });
});

server.listen(port, hostname, () => {
  console.log(`üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ http://${hostname}:${port}`);
});

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤–∏–¥–µ–æ
function getVideoInfo(inputPath) {
  return new Promise((resolve) => {
    console.log('üìä –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∞–π–ª–∞:', inputPath, fs.existsSync(inputPath));
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∏–∫—Ç–∏–≤–Ω—É—é –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å
    resolve({ duration: 3600 }); // 1 —á–∞—Å –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    
    /* –ó–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–µ–º –ø—Ä–æ–±–ª–µ–º–Ω—É—é —á–∞—Å—Ç—å –ø–æ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–º —Ä–µ—à–µ–Ω–∏–µ
    const ffmpegProcess = spawn(ffmpeg, [
      '-i', inputPath,
      '-v', 'error',
      '-select_streams', 'v:0',
      '-show_entries', 'format=duration',
      '-of', 'json'
    ]);

    let output = '';
    let errorOutput = '';

    ffmpegProcess.stdout.on('data', (data) => {
      output += data.toString();
    });

    ffmpegProcess.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });

    ffmpegProcess.on('close', (code) => {
      if (code === 0) {
        try {
          const info = JSON.parse(output);
          resolve({
            duration: parseFloat(info.format.duration) || 3600
          });
        } catch (error) {
          resolve({ duration: 3600 });
        }
      } else {
        resolve({ duration: 3600 });
      }
    });
    */
  });
} 